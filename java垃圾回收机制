可回收对象的判定

讲算法之前，我们先要搞清楚一个问题，什么样的对象是垃圾（无用对象），需要被回收？
目前市面上有两种算法用来判定一个对象是否为垃圾。

1. 引用计数算法

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。
引用计数算法
优点是简单，高效，现在的objective-c用的就是这种算法。
缺点是很难处理循环引用，比如图中相互引用的两个对象则无法释放。


2. 可达性分析算法（根搜索算法）

为了解决上面的循环引用问题，Java采用了一种新的算法：可达性分析算法。
从GC Roots（每种具体实现对GC Roots有不同的定义）作为起点，向下搜索它们引用的对象，可以生成一棵引用树，树的节点视为可达对象，反之视为不可达。
可达性分析算法
OK，即使循环引用了，只要没有被GC Roots引用了依然会被回收，完美！
但是，这个GC Roots的定义就要考究了，Java语言定义了如下GC Roots对象：

虚拟机栈（帧栈中的本地变量表）中引用的对象。
方法区中静态属性引用的对象。
方法区中常量引用的对象。
本地方法栈中JNI引用的对象。


Stop The World

有了上面的垃圾对象的判定，我们还要考虑一个问题，请大家做好心里准备，那就是Stop The World。
因为垃圾回收的时候，需要整个的引用状态保持不变，否则判定是判定垃圾，等我稍后回收的时候它又被引用了，这就全乱套了。所以，GC的时候，其他所有的程序执行处于暂停状态，卡住了。
幸运的是，这个卡顿是非常短（尤其是新生代），对程序的影响微乎其微 （关于其他GC比如并发GC之类的，在此不讨论）。
所以GC的卡顿问题由此而来，也是情有可原，暂时无可避免。

几种垃圾回收算法


那么问题来了，已经知道哪些是垃圾对象了，怎么回收呢？目前主流有以下几种算法。
PS：大家可以先猜猜Java虚拟机（这里默认指Hotspot）采用的是那种算法，…，答对了，是分代回收算法，现在是不是明白了前面堆内存为什么要分新生代和老年代了吧。但是即使猜对了，也要看其他几种算法哦，不然不要说我没提醒你，你会直接看不懂分代回收算法的。

1. 标记清除算法 (Mark-Sweep)

标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。
优点是简单，容易实现。
缺点是容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。
示意图如下（不用我解说了吧）：
标记清除算法示意图

2. 复制算法 (Copying)

复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。
优缺点就是，实现简单，运行高效且不容易产生内存碎片，但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。
从算法原理我们可以看出，Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。
示意图如下（不用我解说了吧）：
复制算法示意图

3. 标记整理算法 (Mark-Compact)

该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。
所以，特别适用于存活对象多，回收对象少的情况下。
示意图如下（不用我解说了吧）：
标记整理算法示意图

4. 分代回收算法

分代回收算法其实不算一种新的算法，而是根据复制算法和标记整理算法的的特点综合而成。这种综合是考虑到java的语言特性的。
这里重复一下两种老算法的适用场景：

复制算法：适用于存活对象很少。回收对象多
标记整理算法: 适用用于存活对象多，回收对象少

刚好互补！不同类型的对象生命周期决定了更适合采用哪种算法。
于是，我们根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Old Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。



